<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="English formatting for unsigned integer IDs and arbitrary data."><meta name="keywords" content="rust, rustlang, rust-lang, englishid"><title>englishid - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../englishid/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../englishid/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate englishid</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.3.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#statics">Statics</a></li><li><a href="#functions">Functions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../englishid/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">englishid</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/englishid/lib.rs.html#1-635">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>English formatting for unsigned integer IDs and arbitrary data.</p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="englishid forbids unsafe code" />
<a href="https://crates.io/crates/englishid"><img src="https://img.shields.io/crates/v/englishid.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/englishid/actions?query=workflow:Tests"><img src="https://img.shields.io/github/workflow/status/khonsulabs/englishid/Tests/main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/englishid/main/englishid/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p>English formatting for unsigned integers. Useful for encoding large IDs in a
human-readable and recognizable format. Uses a modified <a href="https://github.com/khonsulabs/englishid/blob/main/src/wordlist.rs">list of words</a> based on
a <a href="https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases">list created by the EFF</a>.</p>
<h3 id="basic-usage"><a href="#basic-usage">Basic Usage</a></h3>
<p>Generating an ID can be done from any primitive unsigned integer type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">englishid::EnglishId</span>;

<span class="kw">let</span> <span class="ident">english_id</span> <span class="op">=</span> <span class="ident">EnglishId::from</span>(<span class="number">42_u16</span>).<span class="ident">to_string</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">english_id</span>, <span class="string">&quot;accept-abacus&quot;</span>);</code></pre></div>
<p>Use the corresponding parse method to extract the encoded id:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">parsed</span> <span class="op">=</span> <span class="ident">englishid::parse_u16</span>(<span class="string">&quot;accept-abacus&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">parsed</span>, <span class="number">42</span>);</code></pre></div>
<h3 id="restricting-word-length"><a href="#restricting-word-length">Restricting word-length</a></h3>
<p>The <a href="https://github.com/khonsulabs/englishid/blob/main/src/wordlist.rs">wordlist</a> used can encode 52 bits of information in 4 words. If
you’d prefer to restrict your u64 IDs to 52 bits, you can set the number of
words used:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">englishid::EnglishId</span>;

<span class="kw">let</span> <span class="ident">english_id</span> <span class="op">=</span> <span class="ident">EnglishId::from</span>(<span class="number">123456789_u64</span>).<span class="ident">words</span>(<span class="number">4</span>).<span class="ident">to_string</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">english_id</span>, <span class="string">&quot;haunt-subtitle-abandon-abacus&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">englishid::parse_u64</span>(<span class="kw-2">&amp;</span><span class="ident">english_id</span>).<span class="ident">unwrap</span>(), <span class="number">123456789_u64</span>);</code></pre></div>
<p>If a value is ever out of acceptable ranges, <code>Error::ValueOutOfRange</code> will be
returned.</p>
<h3 id="encodingdecoding-arbitrary-data"><a href="#encodingdecoding-arbitrary-data">Encoding/decoding arbitrary data</a></h3>
<p>This crate also offers functions that allow encoding arbitrary bytes of
information using the same word list. If you will always know the data size, you
can use the <code>fixed_length</code> functions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">payload</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">englishid::encode_fixed_length</span>(<span class="ident">payload</span>);
<span class="macro">assert_eq!</span>(<span class="ident">encoded</span>, <span class="string">&quot;hatchback-reissue-residual-overbuilt-ladybug-tusk-buffing&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">englishid::decode_fixed_length</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">payload</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>(), <span class="ident">payload</span>);</code></pre></div>
<p>If you are encoding payloads of differing lengths and want the length to be
encoded into the resulting <code>englishid</code> string, <code>encode()</code> and <code>decode()</code> will do
that for you:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">payload</span> <span class="op">=</span> <span class="string">b&quot;hello world&quot;</span>;
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">englishid::encode</span>(<span class="ident">payload</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">encoded</span>, <span class="string">&quot;able-hatchback-reissue-residual-overbuilt-ladybug-tusk-buffing&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">englishid::decode</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>).<span class="ident">unwrap</span>(), <span class="ident">payload</span>);</code></pre></div>
<p>Or, if you have an enum that can correspond to a byte length, you can use a custom header value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum</span> <span class="ident">PrivateKey</span> {
    <span class="ident">Ed25519</span>([<span class="ident">u8</span>; <span class="number">32</span>]),
    <span class="ident">Ed448</span>([<span class="ident">u8</span>; <span class="number">56</span>])
}

<span class="kw">impl</span> <span class="ident">PrivateKey</span> {
    <span class="kw">fn</span> <span class="ident">as_bytes</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident"><span class="self">Self</span>::Ed25519</span>(<span class="ident">key</span>) =&gt; <span class="ident">key</span>,
            <span class="ident"><span class="self">Self</span>::Ed448</span>(<span class="ident">key</span>) =&gt; <span class="ident">key</span>,
        }
    }

    <span class="kw">fn</span> <span class="ident">kind</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u16</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident"><span class="self">Self</span>::Ed25519</span>(<span class="kw">_</span>) =&gt; <span class="number">1</span>,
            <span class="ident"><span class="self">Self</span>::Ed448</span>(<span class="kw">_</span>) =&gt; <span class="number">2</span>,
        }
    }

    <span class="kw">fn</span> <span class="ident">byte_length</span>(<span class="ident">kind</span>: <span class="ident">u16</span>) -&gt; <span class="ident">usize</span> {
        <span class="kw">match</span> <span class="ident">kind</span> {
            <span class="number">1</span> =&gt; <span class="number">32</span>,
            <span class="number">2</span> =&gt; <span class="number">56</span>,
            <span class="kw">_</span> =&gt; <span class="number">0</span>,
        }
    }
}

<span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="ident">PrivateKey::Ed25519</span>([<span class="number">0</span>; <span class="number">32</span>]);
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">englishid::encode_with_custom_header</span>(<span class="ident">key</span>.<span class="ident">as_bytes</span>(), <span class="ident">key</span>.<span class="ident">kind</span>()).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">englishid::decode_with_custom_header</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">PrivateKey::byte_length</span>).<span class="ident">unwrap</span>(), <span class="ident">key</span>.<span class="ident">as_bytes</span>());</code></pre></div>
<h4 id="limits-on-data-encoding"><a href="#limits-on-data-encoding">Limits on data encoding</a></h4>
<p>When encoding using the <code>fixed_length</code> APIs, there is no limit to the amount of
data that can be encoded.</p>
<p>When using the automatic length header or a custom header, the value in the
header cannot be larger than 8190. This limit may be removed in the future, but
this crate is not intended for large payload encoding.</p>
<h3 id="version-stability"><a href="#version-stability">Version stability</a></h3>
<p>The maintainers of this crate will treat changes to the wordlist as breaking
changes in the eyes of semantic versioning. In the future, this crate <a href="https://github.com/khonsulabs/englishid/issues/2">may
support</a> additional wordlists
which will provide another mechanism to releasing wordlist updates, which should
be infrequent.</p>
<p>If an issue is discovered that generated data that was unable to be recovered
into its original form, fixes will be shipped on minor releases and versions
that can generate invalid data will be yanked.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EnglishId.html" title="englishid::EnglishId struct">EnglishId</a></div><div class="item-right docblock-short"><p>An ID that can be converted to a set of “safe” words.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="englishid::Error enum">Error</a></div><div class="item-right docblock-short"><p>An error from encoding or parsing an <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div></div><h2 id="statics" class="small-section-header"><a href="#statics">Statics</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="static" href="static.WORD_LIST.html" title="englishid::WORD_LIST static">WORD_LIST</a></div><div class="item-right docblock-short"><p>A list of words based on the list <a href="https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases">created by the
EFF</a>,
but with some additional words to expand the list to 8,192 entries.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.decode.html" title="englishid::decode fn">decode</a></div><div class="item-right docblock-short"><p>Decodes <code>englishid</code> that was previously encoded using <a href="fn.encode.html" title="encode()"><code>encode()</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.decode_fixed_length.html" title="englishid::decode_fixed_length fn">decode_fixed_length</a></div><div class="item-right docblock-short"><p>Decodes <code>englishid</code> that was previously encoded using
<a href="fn.encode_fixed_length.html" title="encode_fixed_length()"><code>encode_fixed_length()</code></a>., expecting an output size of <code>length</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.decode_with_custom_header.html" title="englishid::decode_with_custom_header fn">decode_with_custom_header</a></div><div class="item-right docblock-short"><p>Decodes <code>englishid</code> that was previously encoded using
<a href="fn.encode_with_custom_header.html" title="encode_with_custom_header()"><code>encode_with_custom_header()</code></a>. After parsing the embedded header,
<code>callback</code> is invoked with the value. The callback is responsible for
returning the number of bytes the result is expected to contain.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.encode.html" title="englishid::encode fn">encode</a></div><div class="item-right docblock-short"><p>Encodes <code>data</code> using <code>englishid</code> with enough information to be able to be
decoded without additional information. To decode, use the <a href="fn.decode.html" title="decode()"><code>decode()</code></a>
function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.encode_fixed_length.html" title="englishid::encode_fixed_length fn">encode_fixed_length</a></div><div class="item-right docblock-short"><p>Encodes <code>data</code> using <code>englishid</code>, for situations where the decoder knows the
expected length of <code>data</code>. To decode, use the <a href="fn.decode_fixed_length.html" title="decode_fixed_length()"><code>decode_fixed_length()</code></a>
function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.encode_with_custom_header.html" title="englishid::encode_with_custom_header fn">encode_with_custom_header</a></div><div class="item-right docblock-short"><p>Encodes <code>data</code> using <code>englishid</code>, encoding <code>header</code> at the start. To decode, use the <a href="fn.decode_with_custom_header.html" title="decode_with_custom_header()"><code>decode_with_custom_header()</code></a>
function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_u8.html" title="englishid::parse_u8 fn">parse_u8</a></div><div class="item-right docblock-short"><p>Parses a previously-encoded <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_u16.html" title="englishid::parse_u16 fn">parse_u16</a></div><div class="item-right docblock-short"><p>Parses a previously-encoded <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_u32.html" title="englishid::parse_u32 fn">parse_u32</a></div><div class="item-right docblock-short"><p>Parses a previously-encoded <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_u64.html" title="englishid::parse_u64 fn">parse_u64</a></div><div class="item-right docblock-short"><p>Parses a previously-encoded <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_u128.html" title="englishid::parse_u128 fn">parse_u128</a></div><div class="item-right docblock-short"><p>Parses a previously-encoded <a href="struct.EnglishId.html" title="EnglishId"><code>EnglishId</code></a>.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="englishid" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>